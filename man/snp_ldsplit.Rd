% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/split-LD.R
\name{snp_ldsplit}
\alias{snp_ldsplit}
\title{Independent LD blocks}
\usage{
snp_ldsplit(corr, thr_r2, grid_param)
}
\arguments{
\item{corr}{Sparse correlation matrix. Usually the output of \code{\link[=snp_cor]{snp_cor()}}.}

\item{thr_r2}{Threshold under which squared correlations are ignored.}

\item{grid_param}{Grid of parameters to consider, a data frame with
\itemize{
\item \verb{$min_size}: Minimum number of variants in each block.
\item \verb{$max_size}: Maximum number of variants in each block.
\item \verb{$lambda}: Penalty coefficient to apply on the size of the blocks.
Using \code{0} would disable this, while using \code{1e-3} could be a good value
to get more smaller blocks.
}}
}
\value{
Input \code{grid_param} as tibble with six extra columns:
\itemize{
\item \verb{$n_block}: Number of blocks.
\item \verb{$cost}: The sum of squared correlations outside the blocks.
\item \verb{$block_num}: Resulting block numbers for each variant.
\item \verb{$all_last}: Last index of each block.
\item \verb{$all_size}: Sizes of the blocks.
\item \verb{$all_cost}: Internal costs computed.
}
}
\description{
Split a correlation matrix in blocks as independent as possible.
This will find the splitting in blocks that minimize the sum of squared
correlation between these blocks (i.e. everything outside these blocks).
}
\examples{
\dontrun{

  corr <- readRDS(url("https://www.dropbox.com/s/65u96jf7y32j2mj/spMat.rds?raw=1"))

  grid_param <- expand.grid(min_size = c(10, 20),
                            max_size = c(30, 40, 50),
                            lambda = c(0, 1e-3, 1e-2))
  THR_R2 <- 0.005

  (res <- snp_ldsplit(corr, grid_param, thr_r2 = THR_R2))

  all_ind <- head(res$all_last[[5]], -1)

  ## Transform sparse representation into (i,j,x) triplets
  corrT <- as(corr, "dgTMatrix")
  upper <- (corrT@i <= corrT@j & corrT@x^2 >= THR_R2)
  df <- data.frame(
    i = corrT@i[upper] + 1L,
    j = corrT@j[upper] + 1L,
    r2 = corrT@x[upper]^2
  )
  df$y <- (df$j - df$i) / 2

  library(ggplot2)
  ggplot(df) +
    geom_point(aes(i + y, y, color = r2), size = rel(0.5)) +
    coord_fixed() +
    scale_color_gradientn(colours = rev(colorRamps::matlab.like2(100))) +
    theme_minimal() +
    theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) +
    geom_vline(xintercept = all_ind + 0.5, linetype = 3) +
    labs(x = "Position", y = NULL) +
    scale_alpha(guide = 'none')
}
}
